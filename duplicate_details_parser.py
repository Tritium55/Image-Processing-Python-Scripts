#!/usr/bin/env python3
"""
This script provides a GUI to review pairs of duplicate images based on a CSV output file.
It is specifically designed to work with CSV files generated by check_for_duplicates.py to make sure the script didn't
remove any important images by mistake.

Image pair reviewer GUI
- Reads CSV at /mnt/data/duplicate_details.csv with columns:
    "Removed File"  and  "Reason"
- Reason format example:
    "Lower resolution than /path/to/kept.jpg, distance 0.12345"
- Left: Removed File (removed image)
- Right: Kept file parsed from Reason
- Shows image, resolution and basic EXIF metadata, distance
- Up/Down arrows or Prev/Next buttons to move through rows
- Independent zoom/pan per image using mouse wheel and buttons

Dependencies:
- PyQt5
- Pillow
- pandas
"""

import sys
import os
import re
import math
import traceback
from typing import Optional, Tuple, List

from PyQt5 import QtCore, QtGui, QtWidgets
from PIL import Image, ExifTags, ImageFile
import pandas as pd
import csv

ImageFile.LOAD_TRUNCATED_IMAGES = True

# regex to parse Reason like: "Lower resolution than /path/to/kept.jpg, distance 0.123"
# RE_REASON = re.compile(
#     r"Lower resolution than\s+(?P<kept>[^,]+),\s*distance\s*(?P<dist>[-+]?\d*\.?\d+)",
#     re.IGNORECASE
# )

def extract_paths(removed_field: str, reason_field: str):
    """
    Extracts the two image paths from your CSV format.

    CSV format ALWAYS:
    <removed_path> , "Lower resolution than <kept_path>, distance X"
    """

    # --- LEFT / REMOVED PATH ---
    left_path = removed_field.split(",", 1)[0].strip().strip('"')

    # --- RIGHT / KEPT PATH ---
    r = reason_field.strip().strip('"')

    # remove prefix
    prefix = "Lower resolution than"
    if r.lower().startswith(prefix.lower()):
        r = r[len(prefix):].strip()

    # real path always begins at first slash
    slash_pos = r.find("/")
    if slash_pos != -1:
        r = r[slash_pos:]
    else:
        r = ""

    # stop at the comma before distance
    right_path = r.split(",")[0].strip().strip('"')

    # --- DISTANCE ---
    m = re.search(r"distance\s*([0-9.]+)", reason_field)
    distance = float(m.group(1)) if m else None

    return left_path, right_path, distance

def get_exif_dict(image_path: str):
    try:
        img = Image.open(image_path)
        exif = img._getexif()
        if not exif:
            return {}
        out = {}
        for k, v in exif.items():
            tag = ExifTags.TAGS.get(k, k)
            if isinstance(v, bytes):
                try:
                    v = v.decode("utf-8", "ignore")
                except Exception:
                    v = repr(v)
            out[tag] = v
        return out
    except Exception:
        return {}

def normalize_col_name(name: str) -> str:
    # remove BOM, strip whitespace, collapse inner spaces, lowercase
    if name is None:
        return ""
    # remove common BOM char
    name = name.lstrip("\ufeff").strip()
    name = re.sub(r"\s+", " ", name)
    return name.lower()

def find_columns(headers: List[str]) -> Tuple[Optional[str], Optional[str]]:
    """
    Given original headers, return the original header names for removed_file and reason.
    Matching is case-insensitive and whitespace-insensitive.
    """
    norm_map = {normalize_col_name(h): h for h in headers}
    removed_key = None
    reason_key = None
    # exact normalized matches
    if "removed file" in norm_map:
        removed_key = norm_map["removed file"]
    if "reason" in norm_map:
        reason_key = norm_map["reason"]
    # fallback: try to find header containing 'removed' and 'file' tokens
    if removed_key is None:
        for norm, orig in norm_map.items():
            if "removed" in norm and "file" in norm:
                removed_key = orig
                break
    # fallback: try to find header containing 'reason' token
    if reason_key is None:
        for norm, orig in norm_map.items():
            if "reason" in norm:
                reason_key = orig
                break
    return removed_key, reason_key

def try_read_csv(path: str) -> Tuple[Optional[pd.DataFrame], Optional[str]]:
    """
    Read CSV in the exact known format:
    <removed_path> , "Lower resolution than <kept_path>, distance X"

    We *must* enforce:
        sep=","
        quotechar='"'
        engine="python"
        dtype=str
    """

    try:
        df = pd.read_csv(
            path,
            sep=",",
            quotechar='"',
            engine="python",
            dtype=str,
            encoding="utf-8-sig"
        )
        return df.fillna(""), None
    except Exception as e_utf8:
        # fallback to latin1 if encoding is different
        try:
            df = pd.read_csv(
                path,
                sep=",",
                quotechar='"',
                engine="python",
                dtype=str,
                encoding="latin1"
            )
            return df.fillna(""), None
        except Exception as e_latin:
            return None, (
                "Failed to parse CSV using the required format.\n\n"
                f"UTF-8-SIG error:\n{e_utf8}\n\n"
                f"Latin-1 error:\n{e_latin}"
            )

class ImageViewer(QtWidgets.QGraphicsView):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setRenderHint(QtGui.QPainter.Antialiasing)
        self.setRenderHint(QtGui.QPainter.SmoothPixmapTransform)
        self._scene = QtWidgets.QGraphicsScene(self)
        self.setScene(self._scene)
        self.pixmap_item = None
        self._zoom = 0
        self.setTransformationAnchor(QtWidgets.QGraphicsView.AnchorUnderMouse)
        self.setResizeAnchor(QtWidgets.QGraphicsView.AnchorUnderMouse)
        self.setDragMode(QtWidgets.QGraphicsView.ScrollHandDrag)
        self.setViewportUpdateMode(QtWidgets.QGraphicsView.BoundingRectViewportUpdate)

    def load_image(self, pil_image: Optional[Image.Image]):
        self._scene.clear()
        self.pixmap_item = None
        self.reset_transform()
        if pil_image is None:
            return
        data = pil_image.convert("RGBA").tobytes("raw", "RGBA")
        qimg = QtGui.QImage(data, pil_image.width, pil_image.height, QtGui.QImage.Format_RGBA8888)
        pix = QtGui.QPixmap.fromImage(qimg)
        self.pixmap_item = self._scene.addPixmap(pix)
        self._scene.setSceneRect(self.pixmap_item.boundingRect())
        self.fit_in_view()

    def fit_in_view(self):
        if not self.pixmap_item:
            return
        self.resetTransform()
        self._zoom = 0
        self.fitInView(self.pixmap_item, QtCore.Qt.KeepAspectRatio)

    def reset_transform(self):
        self.resetTransform()
        self._zoom = 0

    def wheelEvent(self, event: QtGui.QWheelEvent):
        if not self.pixmap_item:
            return
        delta = event.angleDelta().y()
        if delta > 0:
            self.zoom_in()
        else:
            self.zoom_out()

    def zoom_in(self, step=1):
        self._zoom += step
        self._apply_zoom()

    def zoom_out(self, step=1):
        self._zoom -= step
        self._apply_zoom()

    def _apply_zoom(self):
        if not self.pixmap_item:
            return
        self.resetTransform()
        self.fitInView(self.pixmap_item, QtCore.Qt.KeepAspectRatio)
        factor = math.pow(1.25, self._zoom)
        self.scale(factor, factor)

class MainWindow(QtWidgets.QMainWindow):
    def __init__(self, csv_path: str):
        super().__init__()
        self.setWindowTitle("Duplicate Pair Viewer")
        self.resize(1400, 900)

        df, error = try_read_csv(csv_path)
        if df is None:
            QtWidgets.QMessageBox.critical(self, "CSV Read Error", error)
            sys.exit(1)

        # Find matching columns in a tolerant way
        headers = list(df.columns)
        removed_col, reason_col = find_columns(headers)
        if removed_col is None or reason_col is None:
            detected = headers
            QtWidgets.QMessageBox.critical(
                self, "CSV Header Error",
                "Could not find required columns 'Removed File' and 'Reason' in the CSV.\n\n"
                f"Detected header columns: {detected}\n\n"
                "Header matching is case-insensitive and whitespace-insensitive. "
                "If your column names are different, either rename them to 'Removed File' and 'Reason' "
                "or let me know an example header line so I can adapt the parser."
            )
            sys.exit(1)

        # keep original df but rename the found columns to canonical names for ease of use
        df = df.rename(columns={removed_col: "Removed File", reason_col: "Reason"})
        self.df = df.fillna("")
        self.index = 0

        # UI layout (same structure as before)
        central = QtWidgets.QWidget()
        self.setCentralWidget(central)
        main_layout = QtWidgets.QVBoxLayout(central)

        toolbar = QtWidgets.QHBoxLayout()
        btn_prev = QtWidgets.QPushButton("Prev (↑)")
        btn_next = QtWidgets.QPushButton("Next (↓)")
        btn_prev.clicked.connect(self.on_prev)
        btn_next.clicked.connect(self.on_next)
        toolbar.addWidget(btn_prev)
        toolbar.addWidget(btn_next)
        self.idx_label = QtWidgets.QLabel("")
        toolbar.addStretch()
        toolbar.addWidget(self.idx_label)
        main_layout.addLayout(toolbar)

        viewers_layout = QtWidgets.QHBoxLayout()
        self.left_view = ImageViewer()
        self.right_view = ImageViewer()

        left_col = QtWidgets.QVBoxLayout()
        left_col.addWidget(self.left_view, stretch=1)
        left_meta = QtWidgets.QLabel()
        left_meta.setTextInteractionFlags(QtCore.Qt.TextSelectableByMouse)
        left_meta.setWordWrap(True)
        left_col.addWidget(left_meta)
        left_controls = QtWidgets.QHBoxLayout()
        self.left_zoom_in = QtWidgets.QPushButton("Zoom In")
        self.left_zoom_out = QtWidgets.QPushButton("Zoom Out")
        self.left_fit = QtWidgets.QPushButton("Fit")
        left_controls.addWidget(self.left_zoom_in)
        left_controls.addWidget(self.left_zoom_out)
        left_controls.addWidget(self.left_fit)
        left_col.addLayout(left_controls)

        right_col = QtWidgets.QVBoxLayout()
        right_col.addWidget(self.right_view, stretch=1)
        right_meta = QtWidgets.QLabel()
        right_meta.setTextInteractionFlags(QtCore.Qt.TextSelectableByMouse)
        right_meta.setWordWrap(True)
        right_col.addWidget(right_meta)
        right_controls = QtWidgets.QHBoxLayout()
        self.right_zoom_in = QtWidgets.QPushButton("Zoom In")
        self.right_zoom_out = QtWidgets.QPushButton("Zoom Out")
        self.right_fit = QtWidgets.QPushButton("Fit")
        right_controls.addWidget(self.right_zoom_in)
        right_controls.addWidget(self.right_zoom_out)
        right_controls.addWidget(self.right_fit)
        right_col.addLayout(right_controls)

        viewers_layout.addLayout(left_col, stretch=1)
        viewers_layout.addLayout(right_col, stretch=1)
        main_layout.addLayout(viewers_layout, stretch=1)

        info_layout = QtWidgets.QHBoxLayout()
        self.reason_label = QtWidgets.QLabel()
        self.reason_label.setTextInteractionFlags(QtCore.Qt.TextSelectableByMouse)
        self.distance_label = QtWidgets.QLabel()
        info_layout.addWidget(self.reason_label, stretch=1)
        info_layout.addWidget(self.distance_label)
        main_layout.addLayout(info_layout)

        # Connect buttons
        self.left_zoom_in.clicked.connect(lambda: self.left_view.zoom_in())
        self.left_zoom_out.clicked.connect(lambda: self.left_view.zoom_out())
        self.left_fit.clicked.connect(lambda: self.left_view.fit_in_view())

        self.right_zoom_in.clicked.connect(lambda: self.right_view.zoom_in())
        self.right_zoom_out.clicked.connect(lambda: self.right_view.zoom_out())
        self.right_fit.clicked.connect(lambda: self.right_view.fit_in_view())

        self.left_meta_label = left_meta
        self.right_meta_label = right_meta

        self.update_viewers()

    def keyPressEvent(self, event):
        if event.key() == QtCore.Qt.Key_Up:
            self.on_prev()
        elif event.key() == QtCore.Qt.Key_Down:
            self.on_next()
        else:
            super().keyPressEvent(event)

    def on_prev(self):
        self.index = (self.index - 1) % len(self.df)
        self.update_viewers()

    def on_next(self):
        self.index = (self.index + 1) % len(self.df)
        self.update_viewers()

    def update_viewers(self):
        row = self.df.iloc[self.index]
        
        # extract removed path
        removed_field = row.get("Removed File", "") or ""
        reason_field = row.get("Reason", "") or ""
        
        print(self.df.columns)
        print(self.df.iloc[0])

        left_path, right_path, distance = extract_paths(removed_field, reason_field)
        removed_path = left_path
        kept_path = right_path
        reason = reason_field

        self.idx_label.setText(f"Row {self.index + 1} / {len(self.df)}")

        left_pil = self.safe_open_image(removed_path)
        right_pil = self.safe_open_image(kept_path)

        self.left_view.load_image(left_pil)
        self.right_view.load_image(right_pil)

        left_meta = self.make_meta_text(removed_path, left_pil)
        right_meta = self.make_meta_text(kept_path, right_pil)
        self.left_meta_label.setText(left_meta)
        self.right_meta_label.setText(right_meta)

        # reason and distance display
        self.reason_label.setText(f"<b>Reason:</b> {reason}")
        if distance is not None:
            self.distance_label.setText(f"<b>Distance:</b> {distance}")
        else:
            self.distance_label.setText("")

    def safe_open_image(self, path: Optional[str]) -> Optional[Image.Image]:
        if not path or not isinstance(path, str):
            return None
        path = os.path.expanduser(path)
        if not os.path.exists(path):
            return None
        try:
            img = Image.open(path)
            if img.mode not in ("RGB", "RGBA"):
                img = img.convert("RGBA")
            return img
        except Exception:
            return None

    def make_meta_text(self, path: str, pil_img: Optional[Image.Image]) -> str:
        if not path:
            return "<i>missing path</i>"
        safe_path = path
        if pil_img is None:
            return f"<b>Path:</b> {safe_path}<br><i>Image not found or failed to open</i>"
        try:
            w, h = pil_img.size
            exif = get_exif_dict(path)
            common_keys = ["Make", "Model", "DateTime", "LensModel", "FNumber", "ExposureTime", "ISOSpeedRatings"]
            exif_lines = []
            for k in common_keys:
                if k in exif:
                    exif_lines.append(f"{k}: {exif[k]}")
            exif_text = "<br>".join(exif_lines) if exif_lines else "(no EXIF shown)"
            return f"<b>Path:</b> {safe_path}<br><b>Resolution:</b> {w} × {h}<br>{exif_text}"
        except Exception as e:
            return f"<b>Path:</b> {safe_path}<br><i>Failed to build meta: {e}</i>"

def main():
    app = QtWidgets.QApplication(sys.argv)

    # CSV file dialog
    dlg = QtWidgets.QFileDialog()
    dlg.setWindowTitle("Select duplicate_details.csv")
    dlg.setFileMode(QtWidgets.QFileDialog.ExistingFile)
    dlg.setNameFilter("CSV Files (*.csv);;All Files (*)")

    if dlg.exec_() != QtWidgets.QFileDialog.Accepted:
        sys.exit(0)

    csv_path = dlg.selectedFiles()[0]
    w = MainWindow(csv_path)
    w.show()
    sys.exit(app.exec_())

if __name__ == "__main__":
    main()